<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Why So Serious?</title>
  
    <link rel="icon" href="/blog/assets/smile.JPG">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/blog/assets/header.png)">
        <div class='av-pic' style="background-image: url(/blog/assets/avatar.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>Why So Serious?</div>
        
        <ul>
          
            <a href="/blog/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/blog/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/blog/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/20/Elasticsearch7-13%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">Elasticsearch7.13的新特性</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-20T08:13:42.000Z" itemprop="datePublished">
    2021-07-20
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<h3 id="Frozen-tier现在是可用的"><a href="#Frozen-tier现在是可用的" class="headerlink" title="Frozen tier现在是可用的"></a>Frozen tier现在是可用的</h3><p>Frozen tier和部分挂载的索引（之前称为共享缓存可搜索快照）现在通常是可用的。</p>
<p><em>Pending：什么是Frozen tier？</em></p>
<h3 id="索引运行时字段"><a href="#索引运行时字段" class="headerlink" title="索引运行时字段"></a>索引运行时字段</h3><p>运行时字段可以使你在查询阶段根据其他字段和文档属性动态的创建字段。这些查询阶段的运行时字段在速度方面进行了灵活性优化，并且可以随时更改。ES7.13你也可以创建索引阶段的运行时字段，以便更好的提升查询性能。<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/runtime-indexed.html">索引运行时字段</a></p>
<h3 id="在CIDR范围内无痛匹配IPv4和IPv6地址"><a href="#在CIDR范围内无痛匹配IPv4和IPv6地址" class="headerlink" title="在CIDR范围内无痛匹配IPv4和IPv6地址"></a>在CIDR范围内无痛匹配IPv4和IPv6地址</h3><p>无痛表达式可以在CIDR范围内匹配IPv4和IPv6地址。这对于在安全中区分和分组IP地址或者监控用例时非常有用。这个特性在所有上下文中都可用，包活运行时字段，提取，搜索和聚合。举例来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">CIDR myCidrRange = <span class="hljs-keyword">new</span> CIDR(<span class="hljs-string">&#x27;10.1.1.0/25&#x27;</span>);<br>myCidrRange.contains(<span class="hljs-string">&#x27;10.1.1.127&#x27;</span>); <span class="hljs-comment">// true</span><br>myCidrRange.contains(<span class="hljs-string">&#x27;10.1.1.129&#x27;</span>); <span class="hljs-comment">// false</span><br><br>myCidrRange = <span class="hljs-keyword">new</span> CIDR(<span class="hljs-string">&#x27;2001:0db8:85a3::/64&#x27;</span>);<br>myCidrRange.contains(<span class="hljs-string">&#x27;2001:0db8:85a3:0000:0000:8a2e:0370:7334&#x27;</span>); <span class="hljs-comment">// true</span><br>myCidrRange.contains(<span class="hljs-string">&#x27;2001:0db8:85a3:0001:0000:8a2e:0370:7334&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>


<h3 id="新的查询类型combined-fields"><a href="#新的查询类型combined-fields" class="headerlink" title="新的查询类型combined_fields"></a>新的查询类型combined_fields</h3><p>7.13介绍了一种<strong>combined_fields</strong>查询，是一种搜索多个<em>text</em>字段作为联合字段的查询语句。你可以使用<em>combined_fields</em>查询作为多匹配查询跨字段类型选项的简单化替代。<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-combined-fields-query.html">combined_fields查询文档</a></p>
<h3 id="更快的terms聚合"><a href="#更快的terms聚合" class="headerlink" title="更快的terms聚合"></a>更快的<em>terms</em>聚合</h3><p>当满足以下条件时，会显著的提升<em>terms</em>聚合的速度：</p>
<ul>
<li>没有父或子的聚合</li>
<li>目标索引不包括已经删除的索引的文档或者最近合并的文档</li>
<li>不使用文档级别的安全性</li>
<li>没有顶级查询</li>
<li>某些字段有全局序数，例如<em>keyword</em>或者<em>IP</em>字段</li>
<li>独立的terms个数少于一千个</li>
</ul>
<p>许多时间序列的用例可能满足这些标准，特别是对于冷数据或者frozen tier中的数据。</p>
<h3 id="数据帧分析和推断可编辑"><a href="#数据帧分析和推断可编辑" class="headerlink" title="数据帧分析和推断可编辑"></a>数据帧分析和推断可编辑</h3><p>训练离群点检测、回归和分类模型，然后使用这些模型对输入数据进行推断的能力在7.13中变得普遍可用。</p>
<h3 id="训练模型别名"><a href="#训练模型别名" class="headerlink" title="训练模型别名"></a>训练模型别名</h3><p>为了简化训练模型的部署和升级，7.13中引入了模型别名的概念。当在摄取管道中使用模型别名时，现在可以对基础引用模型进行更改，而不必更新管道。当新模型加载到缓存中时，所有摄取管道的基础引用模型将自动更改。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/20/%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%8E%E5%88%86%E7%89%87%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%BC%B9%E6%80%A7/">Elasticsearch集群节点与分片的扩展性和弹性</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-20T06:43:24.000Z" itemprop="datePublished">
    2021-07-20
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<p>Elasticsearch是高可用并可以根据用户需求进行拓展的，原因是它的分布式特性。你可以向集群添加节点来提升集群能力然后ES会将你的数据和查询分布到所有可用节点上。你无需更改自己的应用，ES知道如何平衡多节点集群以提供高可用和可扩展性。节点越多，集群越强。</p>
<p>高可用和可扩展是如何实现的呢？实际上，ES索引只是一个或多个物理分片的逻辑分组，其中每个分片实际上是一个自包含的索引。通过将一个索引中的文档分布到多个分片且将多个分片分布到多个节点上，ES保证了数据的冗余，这种机制防止硬件出错的情况并且可以在新的节点加入集群时提高查询能力。当一个集群节点增多或者缩减，ES会自动迁移分片并重新平衡集群。</p>
<p>分片有两种类型：主分片和副本分片。一个索引中的每个文档都属于某一个主分片，副本分片是主分片的拷贝，这种复制机制提供数据的冗余副本以防止硬件故障，并提高服务读取请求如搜索或检索文档的容量。</p>
<p>一个索引的主分片数量是固定的，在索引创建时指定，但是副本分片的数量在不会中断索引和查询操作的情况下可随意更改。</p>
<h3 id="需要考虑的事情"><a href="#需要考虑的事情" class="headerlink" title="需要考虑的事情"></a>需要考虑的事情</h3><p>关于分片大小和为索引配置的主分片数量，有许多性能方面的考虑和权衡。分片越多，维护这些索引的开销就越大。分片大小越大，当ES需要重新平衡集群时移动分片花的时间就越久。</p>
<p>查询大量的小分片可以使每个分片的处理速度更快，但是查询越多意味着开销越大，因此查询少量的大分片可能会更快。总之这要视情况而定。</p>
<p>最开始的参考：</p>
<ul>
<li>尽量将分片大小控制在几GB到几十GB之间。对于基于时间的数据，通常情况下分片大小在20GB-40GB之间。</li>
<li>避免分片过多问题。一个节点上的分片数量应该与其堆空间大小成比例，一般来说，每GB的堆空间对应的分片数量应该少于20个。</li>
</ul>
<p>决定这些配置最好的方式就是根据自己的使用场景进行测试。</p>
<h3 id="故障发生情况"><a href="#故障发生情况" class="headerlink" title="故障发生情况"></a>故障发生情况</h3><p>出于性能考虑，在一个集群中的节点应该使用同一个网络。在不同的数据中心节点之间平衡集群中的分片花费的时间太长了，但是高可用架构要求你不能把所有鸡蛋放在一个篮子里。当一个位置发生重大故障时，另一个位置的服务器需要能够无缝接管服务。实现的方案就是跨集群复制<em>Cross-cluster replication</em>（CCR）</p>
<p>CCR提供了一种从主集群自动同步索引到可作为热备份的辅助原创集群的方法。如果主集群挂了，辅助集群可以接管。你也可以使用CCR创建辅助集群以服务与用户地理位置相近的读请求。</p>
<p>跨集群复制是主备复制。主集群上的索引是领导索引，负责处理所有写请求。辅助集群上的索引仅可以处理读请求。</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html">原文</a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/19/%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%88%86%E6%9E%90/">Elasticsearch查询与分析</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-19T10:35:15.000Z" itemprop="datePublished">
    2021-07-19
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>虽然你可以使用ES存储文档、提取文档和元数据，但其真正的强大之处在于能够轻松访问构建在Apache Lucene搜索引擎库上的全套搜索功能。</p>
<p>ES提供了一套简单的，有逻辑的Restful Api来管理你的集群和索引。以及搜索你的数据。如果需要测试，你只需要通过命令行或者通过Kibana上的开发者平台发送请求。对于应用，可以直接使用<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearc Client</a>。</p>
        
          <div class="more-link">
            <a href="/blog/2021/07/19/%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%88%86%E6%9E%90/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/19/%E6%96%87%E6%A1%A3%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/">Elasticsearch文档和索引中的数据</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-19T10:14:53.000Z" itemprop="datePublished">
    2021-07-19
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<p>Elasticsearch（ES）是一种分布式文档存储。不同于关系型数据库存一行有关系的数据，ES存储被序列化成JSON的复杂数据结构。当你在集群中有多个ES节点时，文档也是被分布式存储的并且可以在任意一个节点立即查找到数据。</p>
<p>当一个文档被存储后，它会被索引并且可以被近实时（1秒内）查询到。ES使用到一种名叫倒排索引的数据结构，这种结构支持非常快速的全文查询。简单来说，倒排索引就是列出在所有文档中出现的单个单词，并且标记每个单词在所有文档中的出现情况。</p>
<p>一个索引可以被看作是被优化的文档集合，每个文档时一个字段集合，这个字段就是包含你的数据的key-value键值对。默认情况下，ES会将所有数据按照字段进行索引，每个被索引的字段都有专用的，被优化的数据结构。举例来说，text类型的字段存储在倒排索引中，而数字类型和地理类型的字段被存储在BKD Tree中。这种每种字段用合适的数据结构来组合并返回搜索结果的能力时ES快速检索文档的原因之一。</p>
<p>ES也支持schema-less，这个的意思是文档可以被索引而不需要明确地指定如何处理文档中可能出现的字段。当启用动态mapping时，ES会自动检测并且为索引增加新的字段，这种默认的处理方式使得索引和检索文档变得容易 —— 只需要开始索引文档，ES会检测并用合适的数据类型来匹配文档中的booleans、float和integer值、date或string值。</p>
<p>但是，你自己对数据的了解程度肯定要比ES多，所以你可以自定义规则来控制动态mapping或者明确定义mapping以便完全控制每个字段如何存储并索引。</p>
<p>自定义mapping有如下优势：</p>
<ul>
<li>区分全文字符串（需要分词）和精确字符串（keyword）</li>
<li>执行特定语言的文本分析</li>
<li>为局部的搜索匹配优化字段类型</li>
<li>使用用户自定义日期格式 </li>
<li>使用一些相近的无法自动区分的数据结构，比如geo_point和geo_shape</li>
</ul>
<p>我们经常会用不同的方式索引同一个字段以便满足不同的需求。例如，你可能想把一个字符串索引为text类型用于全文检索，又想把该字段索引为keyword用于排序或者聚合。或者，你可能想用多种语言分析器来处理用户输入的字符串。</p>
<p>在索引时用到的分析链在搜索过程中也会用到。当你查询一个全文索引字段时，在查询条目被找到之前查询文本会经历相同的分析。（也就是说，索引文档与查询文档的分析过程是一样的）</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/documents-indices.html">原文</a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/19/%E4%BB%80%E4%B9%88%E6%98%AFElasticsearch/">什么是Elasticsearch</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-19T10:13:21.000Z" itemprop="datePublished">
    2021-07-19
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<p>Elasticsearch是Elastic栈的中心，是一个分布式搜索与分析引擎。Logstash和Beat使向Elasticsearch中收集、聚合、丰富数据并且存储变得容易。Kibana可以让人们交互式的探索、可视化、分享数据的探索角度并且可以管理和监控Elastic栈。Elasticsearch则用于处理数据索引、搜索、分析。</p>
<p>Elasticsearch对所有类型的数据都提供了近实时的查询与分析。不论你的数据是结构化或者非结构化、数字类型的还是地理数据，Elasticsearch都可以高效存储并且用支持快速查询的方式来索引数据。你可以随意的进行数据提取和信息聚合以便发现数据中的某些趋势和模式。随着数据体积的增大，Elasticsearch的分布式特性可以让用户无缝扩展集群。</p>
<p>虽然不是所有问题都是有关搜索的问题，Elasticsearch提供了快速与灵活的方式去处理数据，以下是一些用户场景的大致分类：</p>
<ul>
<li>在APP或者网站上添加一个搜索框</li>
<li>保存并分析日志，指标和安全事件数据</li>
<li>使用机器学习来实时对数据行为进行建模</li>
<li>利用Elasticsearch作为存储引擎使业务工作流自动化</li>
<li>使用Elasticsearch作为一个地理信息系统来管理、集成和分析空间数据</li>
<li>使用Elasticsearch作为一个生物信息的搜索工具来存储并处理基因数据</li>
</ul>
<p>我们对用户使用Elasticsearch进行一些新奇的搜索方式感到惊讶，但是不论你的使用场景是否与上述提到的场景有相似的地方，或者你用Elasticsearch解决一个新问题，你用Elasticsearch处理数据、文档和索引的方式总是相同的。</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html">原文</a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/17/%E4%BB%80%E4%B9%88%E6%98%AFHive/">什么是Hive</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-17T10:24:18.000Z" itemprop="datePublished">
    2021-07-17
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<p>Hive到底是什么？它的存在是为了解决什么问题？Hive有什么优缺点？它与传统数据库之间有什么关系？Hive在大数据分析中扮演着什么角色？Let’s explore Hive together.</p>
<h2 id="Hive是什么"><a href="#Hive是什么" class="headerlink" title="Hive是什么"></a>Hive是什么</h2><p>简单来说，Hive是一种将SQL语句转换为MapReduce/Tez/Spark程序的工具。有了Hive我们不需要学习如何写MapReduce/Tez/Spark程序来进行数据分析，只需使用我们已经熟悉的SQL语言进行我们需要的数据查询，Hive会将SQL解析并转化为相应的计算程序在HDFS上运行并返回结果。</p>
<p><strong>官方定义</strong></p>
<blockquote>
<p>The Apache Hive data warehouse software facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. Built on top of Apache Hadoop, it provides:</p>
<ul>
<li>Tools to enable easy access to data via SQL, thus enabling data warehousing tasks such as extract/transform/load(ETL), reporting, and data analysis</li>
<li>A mechanism to impose structure on a variety of data formats</li>
<li>Access to files stored either directly in Apache HDFS or in other data storage systems such as Apache HBase</li>
<li>Query execution using Apache Hadoop MapReduce, Apache Tez or Apache Spark frameworks.</li>
</ul>
<hr>
<p>数据仓库工具Hive致力于使用SQL来简化在分布式存储中的数据读写以及数据集管理问题。基于Apache Hadoop实现，Hive提供了：</p>
<ul>
<li>通过SQL简化数据访问的工具，即简化数据仓库任务如数据提取、转化、加载、报告和数据分析等。</li>
<li>将各种各样的数据格式转换为特定结构的机制</li>
<li>可以直接访问HDFS或者其他数据存储系统如HBase中的文件</li>
<li>可以指定数据计算框架如MapReduce、Tez或者Spark来执行查询</li>
</ul>
</blockquote>
<p><strong>为什么是基于Hadoop</strong></p>
<p>根据上述定义可以看到:</p>
<ol>
<li>Hive处理的数据实际上是存放在HDFS或其他存储系统中，它本身不会存储数据</li>
<li>底层数据计算框架使用MapReduce、Tez或Spark</li>
<li>Hive调度资源使用Yarn框架</li>
</ol>
<p>所以Hive实际上是一个Hadoop的工具，为了帮助大家更加方便的使用Hadoop来工作，如果没有Hadoop，或许Hive存在的意义也就没有了吧。</p>
<h2 id="Hive的优缺点"><a href="#Hive的优缺点" class="headerlink" title="Hive的优缺点"></a>Hive的优缺点</h2><p><strong>优点</strong></p>
<ol>
<li>使用简单，用户只需会使用SQL即可</li>
<li>使数据分析工作变得简单，处理大数据优势明显</li>
<li>支持用户自定义函数</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>表达能力有限，无法表达迭代式算法（如第一个MapReduce程序的输出作为第二个MapReduce程序的输入）</li>
<li>Hive转换SQL生成的MapReduce程序通常不够有效率</li>
<li>Hive调优困难，粒度较粗</li>
</ol>
<h2 id="Hive架构组成"><a href="#Hive架构组成" class="headerlink" title="Hive架构组成"></a>Hive架构组成</h2><ul>
<li>两种客户端<ol>
<li>CLI（command-line interface）命令行客户端</li>
<li>JDBC客户端</li>
</ol>
</li>
<li>四种驱动<ol>
<li>SQL Parser：sql解析器，检查sql语法</li>
<li>Physical Plan：编译器，将sql语句转换为MapReduce或者指定的计算框架程序</li>
<li>Query Optimizer：优化器，优化查询</li>
<li>Execution：执行器，执行计算程序</li>
</ol>
</li>
<li>元数据库Metastore<ol>
<li>Metastore是一个数据库，用于存储需要处理的数据的元数据，比如表名，表所属的数据库，表的用户信息，表字段，表数据所在的目录等等，将这些元数据存储在一个关系型数据库中，这个数据库就是Hive的Metastore</li>
<li>Hive自带的Metastore是一个Derby数据库，但因为Derby不支持并发，一遍将Derby替换为Mysql</li>
</ol>
</li>
</ul>
<p>所以Hive处理过程中会读取两部分数据：存放在HDFS中的结构化数据（要处理的大数据）以及存放在Mysql中的元数据（目标数据信息）。通过读取元数据信息，找到对应的字段；然后把字段映射到结构化数据中，通过映射形成一张虚表，用于Hive数据查询与分析。</p>
<h2 id="Hive的特点"><a href="#Hive的特点" class="headerlink" title="Hive的特点"></a>Hive的特点</h2><ul>
<li>Hive是针对数据仓库设计的，主要用于读，所有的数据在加载时已经确定好，适合处理静态数据</li>
<li>Hive本身计算的延迟较高</li>
<li>Hive基于Hadoop，也具备可扩展性，支持并发运行</li>
<li>Hive是一种数仓工具，不是数据库</li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/02/%E9%AB%98%E6%80%A7%E8%83%BDMysql/">高性能Mysql</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-02T12:01:36.000Z" itemprop="datePublished">
    2021-07-02
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Note/">Note</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<ul>
<li><p>表设计</p>
<ol>
<li><p>自增主键：顺序插入减少数据分片，数字的排序性能更好，聚簇索引减少回表查询</p>
</li>
<li><p>  外键：特定应用保持数据一致性</p>
</li>
<li><p> 为列选择合适的数据类型，减少内存占用</p>
</li>
<li><p> 避免一个表中出现太多的列：行结构转换的代价依赖于列的数量</p>
</li>
<li><p> 范式与反范式表的设计：范式查询时经常需要关联，反范式所有数据都在同一张表中因此查询不需要关联。实际中不会有完全遵循范式或者反范式的设计</p>
</li>
<li><p>询不需要关联。实际中不会有完全遵循范式或者反范式的设计</p>
</li>
</ol>
</li>
<li><p>索引设计</p>
<ol>
<li><p> 索引是在引擎层而非服务器层实现的</p>
</li>
<li><p>索引有：B-Tree，哈希索引，空间数据索引（R-Tree，地理位置），全文索引</p>
</li>
<li><p>索引优势：减少服务器需要扫描的数据量；帮助服务器避免排序和创建临时表；磁盘顺序I/O</p>
</li>
<li><p>查询条件中，列为表达式的一部分时，该列无法使用索引</p>
</li>
<li><p>索引列的顺序：将选择性高的列放在索引的最前列</p>
</li>
<li><p>覆盖索引：直接从索引中读取数据无需回表查询，性能高</p>
</li>
<li><p>索引最左匹配原则</p>
</li>
<li><p>全文索引：自然语言匹配，布尔匹配</p>
</li>
</ol>
</li>
<li><p>查询优化</p>
<ol>
<li><p>避免不必要的排序，如group by时可以指定order by null避免排序</p>
</li>
<li><p> limit 10，10会先查出100条符合条件的数据，然后丢弃前面的90条返回最后10条。数据量过大时，用下一页而不是跳转的方式会时查询性能更好（id &gt; ${id} limit 10）</p>
</li>
<li><p>善于使用explain分析需要执行的语句，从分析结果优化查询</p>
</li>
<li><p>对于大查询采用分治的思想，将大查询切分为小查询，每个查询功能完全一样，多次执行（如删除旧数据）</p>
</li>
<li><p>分解关联查询：让缓存的效率更高；执行单个查询会降低对锁的竞争；小查询本身的效率很可能更高；在应用层做关联对数据库依赖降低，更容易做到高性能和可扩展；可以减少冗余记录的查询</p>
</li>
</ol>
</li>
<li><p>查询优化器做了什么</p>
<ol>
<li><p>重新定义关联表的顺序</p>
</li>
<li><p>将外连接转化为内连接</p>
</li>
<li><p>使用等价变换规则</p>
</li>
<li><p>优化count(), min(), max()</p>
</li>
<li><p>预估并转换为常数表达式</p>
</li>
<li><p>覆盖索引扫描</p>
</li>
<li><p>子查询优化</p>
</li>
<li><p>提前终止查询：满足需求时立刻终止查询</p>
</li>
<li><p>等值传播</p>
</li>
<li><p>列表IN()的比较：将in列表中的数据先进行排序，然后通过二分法确定列表中的值是否满足条件</p>
</li>
<li><p>… …</p>
</li>
</ol>
</li>
<li><p>使用缓存</p>
<ol>
<li><p> mysql服务缓存，只有完全相同的两条查询语句，后者才能命中前者的缓存。非查询语句不会缓存，即非查询语句永远不可能命中缓存</p>
</li>
<li><p>可以指定查询语句是否被缓存，或指定是否需要查询缓存</p>
</li>
<li><p>应用层缓存：本地缓存，redis缓存等</p>
</li>
</ol>
</li>
<li><p>数据同步</p>
<ol>
<li><p>主服务的二进制日志（BinLog）被读取到从服务的中继日志中，然后有一个线程从中继日志中同步数据</p>
</li>
<li><p>基于行的复制：保存数据的二进制，直接复制；基于语句的复制：保存生成数据的命令，重新执行一遍命令</p>
</li>
</ol>
</li>
<li><p>分库分表</p>
<ol>
<li>真正需要时才考虑这种操作，否则只会增加不必要的性能损耗和维护难度</li>
</ol>
</li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/06/27/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/">广度优先搜索算法</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-27T07:32:43.000Z" itemprop="datePublished">
    2021-06-27
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/Algorithm/">Algorithm</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>广度优先算法按照一种同心圆的方式，首先访问所有和初始顶点邻接的顶点，然后访问与邻接节点邻接的所有未访问到的节点，以此类推，直到所有与初始顶点同在一个连通分量中的顶点都访问过了为止。如果图中仍然存在未被访问的节点，该算法必须从图的其他连通分量中的任意顶点重新开始。</p>
<p>使用<strong>队列</strong>来跟踪广度优先搜索的操作是比较方便的，该队列先从遍历的初始顶点开始，将该顶点标记为已访问。在每次迭代的时候，该算法找出所有和队头顶点邻接的未访问节点，并将它们标记为已访问，再把它们入队，然后将队头节点从队列中移除(因为该节点所有可能的下一步已经在队列中，该节点被pass)。</p>
<p>上述介绍比较难懂，广度优先算法致力于解决的问题可以概括为：在一个图中已知起点与终点，求从起点出发到终点的最短路径。起点即初始节点，终点为目标节点，从初始节点出发开始广度优先遍历搜索，第一次到达目标节点时走过的路径即位最短路径。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li><p>伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">BFS(Graph)<br>  <span class="hljs-comment">//实现给定图的广度优先查找</span><br>  <span class="hljs-comment">//输入：图G=&lt;V,E&gt;</span><br>  <span class="hljs-comment">//输出：图G的顶点，按照被BFS遍历访问的先后次序，用连续的整数标记</span><br>  <span class="hljs-comment">//将V中的每个顶点标记为0，表示未访问</span><br>  count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> each vertex v in V <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> v is marked with <span class="hljs-number">0</span><br>      bfs(v)<br>  <br>  bfs(v)<br>      <span class="hljs-comment">//访问与v邻接的所有未访问节点，根据访问顺序标记值count</span><br>      count++<br>      mark v with count and initialize a queue with v<br>      <span class="hljs-keyword">while</span> the queue is not empty <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">for</span> each vertex w in V adjacent to the front vertex <span class="hljs-keyword">do</span><br>          <span class="hljs-keyword">if</span> w is marked with <span class="hljs-number">0</span><br>            count++<br>            mark w with count<br>            add w to the queue<br>        remove the front vertex from the queue<br>      <br></code></pre></td></tr></table></figure></li>
<li><p>BFS实现框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回从起始节点到目标节点所需要的最少步数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Node start, Node target)</span> </span>&#123;<br>  Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  Set&lt;Node&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  q.offer(start);<br>  visited.add(start);<br>  <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;<br>    <span class="hljs-keyword">int</span> size = q.size();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      Node cur = q.poll();<br>      <span class="hljs-keyword">if</span>(cur.equals(target) &#123;<br>        <span class="hljs-keyword">return</span> step;<br>      &#125;<br>      <span class="hljs-comment">//将当前节点的所有邻接节点加入遍历队列</span><br>      <span class="hljs-keyword">for</span>(Node n : cur.adjacent()) &#123;<br>        <span class="hljs-comment">//这里还可以根据限制条件做过滤</span><br>        <br>        <span class="hljs-comment">//判断是否被访问过</span><br>        <span class="hljs-keyword">if</span>（n not in visited) &#123;<br>          q.offer(n);<br>          visited(n);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//当一个节点的所有下一步都搜索完成时，步数加一</span><br>      step++;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="算法实践"><a href="#算法实践" class="headerlink" title="算法实践"></a>算法实践</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/open-the-lock/">Leetcode 752</a></p>
<p>题目可以简单描述为：</p>
<p>一个锁上有四个转盘，每个转盘上有0-9十个数字，每次只能转一个转盘上的一个数字，求从0000开始转到目标密码target需要的次数，在此过程中，不能出现给定的数字，即deadends数组中的所有元素都不能出现。</p>
<p>根据上述BFS算法的实现框架，该问题的解决如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> </span>&#123;<br>      <span class="hljs-comment">//将deadends初始化在visited中，是因为可以视deadends为已访问的节点，遇到时跳过</span><br>    	Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));<br>      Queue&lt;String&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>      path.offer(<span class="hljs-string">&quot;0000&quot;</span>);<br>      <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (!path.isEmpty()) &#123;<br>          <span class="hljs-keyword">int</span> size = path.size();<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; s &lt; size; s++) &#123;<br>              String p = path.poll();<br>              <span class="hljs-keyword">if</span> (visited.contains(p)) &#123;<br>                  <span class="hljs-keyword">continue</span>;<br>              &#125;<br>              <span class="hljs-keyword">if</span> (target.equals(p)) &#123;<br>                  <span class="hljs-keyword">return</span> step;<br>              &#125;<br>              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                  String up = upward(p, i);<br>                  path.offer(up);<br>                  String down = downward(p, i);<br>                  path.offer(down);<br>              &#125;<br>              visited.add(p);<br>          &#125;<br>          step++;<br>      &#125;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;  <br>  <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">upward</span><span class="hljs-params">(String path, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>      <span class="hljs-keyword">char</span>[] pc = path.toCharArray();<br>      <span class="hljs-keyword">if</span> (pc[index] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>          pc[index] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(pc);<br>      &#125;<br>      pc[index]--;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(pc);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">downward</span><span class="hljs-params">(String path, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>      <span class="hljs-keyword">char</span>[] pc = path.toCharArray();<br>      <span class="hljs-keyword">if</span> (pc[index] == <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>          pc[index] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(pc);<br>      &#125;<br>      pc[index]++;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(pc);<br>  &#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li>图以邻接表形式存储时，最坏情况下，每个节点与每条边都需要访问一次，时间复杂度为  <em>O(|V| + |E|)</em></li>
<li>图以邻接矩阵存储时，最坏情况下，查找每个节点的邻接节点需要时间为 <em>O(V)</em>, 即该节点所在的行和列，V个节点的时间复杂度为 <em>O(|V|^2)</em></li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/05/23/%E5%89%8D%E7%BC%80%E6%A0%91Trie%E7%9A%84%E5%AE%9E%E7%8E%B0/">前缀树Trie的实现</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-23T10:30:27.000Z" itemprop="datePublished">
    2021-05-23
  </time>
  
  
</div>

    </header>
    <div>
      
        <a id="more"></a>

<h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><p>Trie树，也叫做字典树，是一种有序树，用于保存一种映射关系，其中映射的键通常为字符串，且键并不直接保存在节点中，而是由节点在树中的位置决定。一个节点所有的子孙都具有相同的前缀，也就是该节点所对应的字符串，而跟节点对应空字符串。一般情况下，不是所有的节点都有对应的值，而是只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p><em>应用 ： Trie树常用于搜索提示。比如当输入一个网址，可以自动搜索出其他可能的选择，当没有完全匹配的搜索结果时，可以返回前缀最相似的可能值。</em></p>
<h3 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h3><ul>
<li><p>Trie的节点结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>  <span class="hljs-comment">//用来标示该节点是否为一个串的结束节点</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br>  <span class="hljs-comment">//字母映射表（26个位置对应26个字母）</span><br>  <span class="hljs-keyword">private</span> TrieNode[] next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>字符串（word）插入</p>
<p>首先从跟节点的子节点开始与word第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的节点，知道插入完word的最后一个字符，同时将结束标记为设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>  <span class="hljs-comment">//用新的引用进行遍历</span><br>  TrieNode node = root;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>    <span class="hljs-keyword">if</span> (node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>      node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br>    node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>  &#125;<br>  node.isEnd = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>字符串（word）查找</p>
<p>从根节点的子节点开始，一直向下匹配，若出现节点值为空的情况说明没找到返回false，如果匹配到了最后一个字符，则判断该节点是否为一个字符串的结束节点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>  TrieNode node = root;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>    <span class="hljs-keyword">if</span> (node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> node.isEnd;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>前缀匹配</p>
<p>与搜索完全一致，区别在于无需判断最后一个字符对应的节点是否为某个串的结束节点。</p>
</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>Trie树的形状与单词的插入或删除顺序无关，即给定一组单词，Trie树的形状时唯一的</li>
<li>查找或插入一个长度为L的单词，访问next数组的最大次数为L+1次，和Trie树中包含着多少个单词无关</li>
<li>Trie树中每个节点都保留着一个字母表，有空间浪费。若Trie树的高度为n，字母表的大小为m（一般常见英文字母表为26，但其他语言不一定），那么最坏情况下，即Trie树中没有相同前缀的单词，空间复杂度为O(m^n)</li>
</ol>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现前缀树（Trie）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2021/5/23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TrieNode root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br><br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>            &#125;<br>            node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.isEnd;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Boolean isEnd;<br>        <span class="hljs-keyword">private</span> TrieNode[] next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getEnd</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> isEnd;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">(Boolean end)</span> </span>&#123;<br>            isEnd = end;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> TrieNode[] getNext() &#123;<br>            <span class="hljs-keyword">return</span> next;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(TrieNode[] next)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Trie t = <span class="hljs-keyword">new</span> Trie();<br>        t.insert(<span class="hljs-string">&quot;word&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/blog/">« prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/">next »</a>
    </nav>
  </section>


            <footer>
    <div>© 2021 - Levi </div>
    <div>
        <span>
<!--            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-->
            Homo sum, humani nihil a me alienum puto
        </span>
    </div>
<!--    {% if theme.footer.counter %}-->
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">Views <span id="busuanzi_value_site_pv"></span> </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Visitors <span id="busuanzi_value_site_uv"></span> </span>
<!--    {% endif %}-->
</footer>

        </div>
    </div>
</div>

<script src="/blog/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>