<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Why So Serious?</title>
  
    <link rel="icon" href="/blog/assets/smile.JPG">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/blog/assets/header.png)">
        <div class='av-pic' style="background-image: url(/blog/assets/avatar.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>Why So Serious?</div>
        
        <ul>
          
            <a href="/blog/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/blog/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/blog/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
      <div class='ListMeta'>
  <time datetime="2023-02-19T05:58:42.212Z" itemprop="datePublished">
    2023-02-19
  </time>
  
  
</div>

    </header>
    <div>
      
        <h1 id="网络相关知识总结"><a href="#网络相关知识总结" class="headerlink" title="网络相关知识总结"></a>网络相关知识总结</h1><h2 id="Https与Http对比"><a href="#Https与Http对比" class="headerlink" title="Https与Http对比"></a>Https与Http对比</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Http和Https都是互联网中常见的通信协议，其中Https是在Http的基础上加入了安全层，使用SSL/TLS协议对通信内容进行加密和认证，从而提高了数据传输的安全性。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>安全性：Http是明文传输，数据容易被窃听、篡改和伪造，安全性较低；Https使用SSL/TLS加密技术，保证数据传输的正确性</li>
<li>速度：Https比Http的传输速度慢，是因为Https需要在传输层加入加密和解密的过程，增加了数据传输时间</li>
<li>费用：Https需要购买证书，而Http则完全免费</li>
</ol>
<h3 id="Https的原理"><a href="#Https的原理" class="headerlink" title="Https的原理"></a>Https的原理</h3><p>Https的原理是在客户端和服务器之间建立一条SSL/TLS加密通道，通过在SSL/TLS协议中使用公钥和私钥的方式对通信内容进行加密和认证，从而保证数据传输的安全性。具体来说，Https的通信过程如下：</p>
<ol>
<li>   客户端想服务器发起Https请求</li>
<li>   服务器将自己的公钥发送给客户端</li>
<li>   客户端使用公钥加密生产一个随机数，然后将加密后的随机数发送给服务器</li>
<li>   服务器使用自己的私钥解密客户端发送的随机数，然后使用这个随机数生成对称加密的算法密钥，用来加密数据</li>
<li>   服务器将加密后的数据发送给客户端</li>
<li>   客户端使用对称加密算法的密钥来解密服务器发送的数据，得到原始数据</li>
</ol>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>Https可以使用Http的幂等性方法，如GET方法进行查询，PUT和DELETE方法进行数据更新和删除等。同时可以通过在客户端和服务器之间进行同步的方式来避免重复请求，例如客户端设置一个标记符来标记每个请求的唯一性，在服务器端进行判断和去重等；还可以在数据库层面保证幂等性。</p>
<h2 id="Session和Cookie介绍"><a href="#Session和Cookie介绍" class="headerlink" title="Session和Cookie介绍"></a>Session和Cookie介绍</h2><p>Session和Cookie都是Web应用中常用的状态管理技术，它们用于在客户端和服务器之间维护状态信息，实现用户身份认证，数据缓存等功能，主要作用和区别为：</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie时浏览器保存在客户端的一段文本信息，主要用于表示用户身份信息，存储用户的偏好设置等。Cookie通常由服务器生成，在响应头中通过Set-Cookie字段返回给客户端，客户端将Cookie保存在本地，在后续的请求中将Cookie带到服务器，从而实现状态的维护，Cookie可以设置过期时间，路径，域名等属性，可以控制Cookie的有效期和作用范围。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p> Session是服务器上的一段数据结构，主要用于存储用户的会话信息，缓存数据等。Session通常由服务器生成一个Session ID，通过Cookie或URL参数等方式传递给客户端，在客户端和服务器之间进行状态的交互。客户端在后续的请求中带上Session ID，服务器通过Session ID查找对应的Session数据，从而实现状态的维护。Session可以存储任意类型的数据，但是需要主要Session数据的存储容量，一面占用过多的服务器资源。</p>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p>存储位置不同：Cookie存储在客户端，Session存储在服务器端</p>
</li>
<li><p>存储内容不同：Cookie主要用于存储用户的身份和偏好设置，Seesion主要用于存储用户的会话信息和缓存数据</p>
</li>
<li><p>安全性不同：由于Cookie存储在客户端，容易被篡改或者伪造，安全性较低；Session存储在服务器端，相对安全</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在实际工程中，Session和Cookie都有广泛的应用，一般来说，如果需要保证数据的安全性，可以选择使用Session；如果要在客户端进行状态的维护，可以使用Cookie。例如网站的登录功能通常使用Session来存储用户的登录状态和身份信息，购物网站通常使用Cookie来存储用户的购物车信息和偏好设置等。</p>
<h2 id="浏览器输入URL后发生了什么"><a href="#浏览器输入URL后发生了什么" class="headerlink" title="浏览器输入URL后发生了什么"></a>浏览器输入URL后发生了什么</h2></li>
<li><p>DNS解析：当用户输入URL后，浏览器首先会解析域名，查找域名所对应的IP地址，涉及到DNS协议。如果DNS缓存中存在相应的IP地址，则直接返回；否则会响DNS服务器发送请求，DNS服务器再返回对应的IP地址。</p>
</li>
<li><p>建立TCP连接：浏览器获取到IP地址后，就会想服务器发起TCP连接，使用TCP协议，三次握手后建立连接。</p>
</li>
<li><p>发送HTTP请求：TCP连接建立后，浏览器会向服务器发送HTTP请求，请求中包含浏览器需要获取的资源，请求头等信息。</p>
</li>
<li><p>服务器处理请求并返回响应：服务器在收到请求后，会根据请求的内容进行处理，执行相应的业务逻辑，最终返回HTTP响应，其中包括状态码、响应头和响应题等信息</p>
</li>
<li><p>接受响应内容：浏览器接收到服务器的响应后，会根据响应的类型进行相应的处理。如果是HTML页面，浏览器会对其进行解析，并构建出DOM树，然后渲染出页面；如果是CSS，JS，图片等资源，则会进行响应的处理和加载。</p>
</li>
<li><p>页面渲染：浏览器根据解析出来的DOM树，CSS样式和JS脚本来渲染页面，并在页面中显示出所有的资源。在这个过程中，浏览器会遵循一定的规则来保证页面正确渲染，如盒模型，布局算法等</p>
</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/11/30/Hadoop%E4%B9%8BMapReduce%E4%BB%8B%E7%BB%8D/">Hadoop之MapReduce介绍</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-11-30T08:26:19.000Z" itemprop="datePublished">
    2021-11-30
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Hadoop/">Hadoop</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>MapReduce介绍</p>
        
          <div class="more-link">
            <a href="/blog/2021/11/30/Hadoop%E4%B9%8BMapReduce%E4%BB%8B%E7%BB%8D/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/11/11/Hadoop%E4%B9%8BHdfs/">Hadoop之Hdfs</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-11-11T06:29:13.000Z" itemprop="datePublished">
    2021-11-11
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Hadoop/">Hadoop</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>Hdfs介绍</p>
        
          <div class="more-link">
            <a href="/blog/2021/11/11/Hadoop%E4%B9%8BHdfs/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/09/08/Spark%E9%87%8D%E6%96%B0%E5%88%86%E5%8C%BARepartition/">Spark重新分区Repartition</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-09-08T03:11:46.000Z" itemprop="datePublished">
    2021-09-08
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Spark/">Spark</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Spark/%E8%AF%91/">译</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>在分布式环境中，数据合理分布是提高性能的关键因素。在SparkSQL的DataFrame API中有一个*repartition()*函数用于控制数据在Spark集群上分布。然而高效地使用这个函数并不容易因为改变数据分布就意味着集群节点间物理数据移动（即Shuffle）的损耗。</p>
        
          <div class="more-link">
            <a href="/blog/2021/09/08/Spark%E9%87%8D%E6%96%B0%E5%88%86%E5%8C%BARepartition/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/09/06/Spark%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">Spark相关知识</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-09-06T10:41:08.000Z" itemprop="datePublished">
    2021-09-06
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Spark/">Spark</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>Spark相关知识总结</p>
        
          <div class="more-link">
            <a href="/blog/2021/09/06/Spark%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/08/05/Presto%E4%BB%8B%E7%BB%8D/">Presto介绍</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-08-05T09:17:49.000Z" itemprop="datePublished">
    2021-08-05
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Presto/">Presto</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/big-data/what-is-presto/">转载</a> </p>
<h3 id="什么是Presto"><a href="#什么是Presto" class="headerlink" title="什么是Presto"></a>什么是Presto</h3><p>Presto（或 PrestoDB）是一种开源的分布式 SQL 查询引擎，从头开始设计用于针对任何规模的数据进行快速分析查询。它既可支持非关系数据源，例如 Hadoop 分布式文件系统 (HDFS)、<a target="_blank" rel="noopener" href="https://aws.amazon.com/s3/">Amazon S3</a>、Cassandra、MongoDB 和 <a target="_blank" rel="noopener" href="https://aws.amazon.com/emr/details/hbase/">HBase</a>，又可支持关系数据源，例如 MySQL、PostgreSQL、<a target="_blank" rel="noopener" href="https://aws.amazon.com/redshift/">Amazon Redshift</a>、Microsoft SQL Server 和 Teradata。</p>
        
          <div class="more-link">
            <a href="/blog/2021/08/05/Presto%E4%BB%8B%E7%BB%8D/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/26/Elasticsearch%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2%E4%B8%8ETranslog/">Elasticsearch近实时搜索与Translog</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-26T07:39:11.000Z" itemprop="datePublished">
    2021-07-26
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>Elasticsearch基于Lucene，Lucene搜索是按segment进行的，每一个segment本身就是一个倒排索引，一个Lucene倒排索引包含segment集合和一个提交点（是一个列出了所有已知segment的文件）。新的文档首先被添加到内存的lucene索引缓存中，然后写入到一个基于磁盘的segment，在一次提交后，一个新的segment被添加到提交点并且清空缓存。</p>
        
          <div class="more-link">
            <a href="/blog/2021/07/26/Elasticsearch%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2%E4%B8%8ETranslog/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/23/Elasticsearch%E5%9F%BA%E4%BA%8E%E4%BB%B2%E8%A3%81%E7%9A%84%E9%80%89%E4%B8%BE%E7%AD%96%E7%95%A5/">Elasticsearch基于仲裁的选举策略</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-23T02:52:46.000Z" itemprop="datePublished">
    2021-07-23
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>选举主节点和改变集群状态是两个最根本的任务因为所有正常的主节点必须一起正常工作。即使在某些节点挂了时维持这些工作的稳定是非常重要的。ES通过考虑每个动作都收到仲裁节点成功的响应来实现健壮性，仲裁节点是集群中可用主节点的子集。使用一个子集响应的优点是，即使某些节点挂了也不会阻止集群继续执行任务。仲裁节点需要谨慎选取以防集群<em>脑裂</em>，就是说集群被分成了两部分并且每一部分可能做出一些与另一部分不一致的决定。</p>
        
          <div class="more-link">
            <a href="/blog/2021/07/23/Elasticsearch%E5%9F%BA%E4%BA%8E%E4%BB%B2%E8%A3%81%E7%9A%84%E9%80%89%E4%B8%BE%E7%AD%96%E7%95%A5/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/blog/2021/07/22/ES%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0/">Elasticsearch集群节点发现</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-22T09:35:45.000Z" itemprop="datePublished">
    2021-07-22
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/blog/categories/BigData/">BigData</a> }
  </li>

  <li class="meta-text">
  { <a href="/blog/categories/BigData/Elasticsearch/">Elasticsearch</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>节点发现是ES集群formation模块找到其他节点形成集群的过程。当你启动一个ES节点或者一个节点认为主节点挂了并开始选择新的主节点时运行节点发现任务。</p>
        
          <div class="more-link">
            <a href="/blog/2021/07/22/ES%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">next »</a>
    </nav>
  </section>


            <footer>
    <div>© 2023 - Levi </div>
    <div>
        <span>
<!--            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-->
            Homo sum, humani nihil a me alienum puto
        </span>
    </div>
<!--    {% if theme.footer.counter %}-->
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">Views <span id="busuanzi_value_site_pv"></span> </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Visitors <span id="busuanzi_value_site_uv"></span> </span>
<!--    {% endif %}-->
</footer>

        </div>
    </div>
</div>

<script src="/blog/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>